package index

import (
	"context"
	"encoding/json"

	"github.com/nonibytes/ministore/pkg/ministore/backend"
	"github.com/nonibytes/ministore/pkg/ministore/cursor"
	mserrors "github.com/nonibytes/ministore/pkg/ministore/errors"
	"github.com/nonibytes/ministore/pkg/ministore/item"
	"github.com/nonibytes/ministore/pkg/ministore/plan"
	"github.com/nonibytes/ministore/pkg/ministore/query"
	"github.com/nonibytes/ministore/pkg/ministore/schema"
)

type Index struct {
	name   string
	schema schema.Schema
	store  backend.IndexStore
	opts   IndexOptions
}

func New(name string, sch schema.Schema, store backend.IndexStore, opts IndexOptions) *Index {
	return &Index{name: name, schema: sch, store: store, opts: opts}
}

func (i *Index) Name() string          { return i.name }
func (i *Index) Schema() schema.Schema { return i.schema }

func (i *Index) Put(ctx context.Context, doc map[string]any) error {
	return i.store.Put(ctx, doc)
}

func (i *Index) Get(ctx context.Context, path string) (item.ItemView, error) {
	return i.store.Get(ctx, path)
}

func (i *Index) Peek(ctx context.Context, path string) (map[string]any, error) {
	return i.store.Peek(ctx, path)
}

func (i *Index) Delete(ctx context.Context, path string) (bool, error) {
	return i.store.Delete(ctx, path)
}

func (i *Index) DeleteWhere(ctx context.Context, q string) (int, error) {
	cq, err := i.compileQuery(q)
	if err != nil {
		return 0, err
	}
	return i.store.DeleteWhere(ctx, cq)
}

func (i *Index) Search(ctx context.Context, q string, opts SearchOptions) (SearchResultPage, error) {
	cq, err := i.compileQuery(q)
	if err != nil {
		return SearchResultPage{}, err
	}

	// Cursor hash validation is enforced here so adapters can stay simpler.
	schemaJSON, err := i.schema.ToCanonicalJSON()
	if err != nil {
		return SearchResultPage{}, err
	}
	h, err := cursor.HashQuery(schemaJSON, q, opts.Rank)
	if err != nil {
		return SearchResultPage{}, err
	}

	// Resolve after token -> cursor.Position.
	var afterPos *cursor.Position
	if opts.After != "" {
		pos, err := i.resolveCursor(ctx, opts)
		if err != nil {
			return SearchResultPage{}, err
		}
		if pos.Hash != h {
			return SearchResultPage{}, mserrors.NewError(mserrors.ErrCursor, "cursor does not match query/schema/rank")
		}
		afterPos = &pos
	}

	// Attach explain plan generated by compiler; adapter may append execution details.
	page, err := i.store.Search(ctx, cq, opts)
	if err != nil {
		return SearchResultPage{}, err
	}
	if opts.Explain {
		page.ExplainPlan = append([]string{}, cq.ExplainSteps...)
	}

	// NOTE: adapter is responsible for next cursor generation since it knows sort keys.
	_ = afterPos // reserved for future if we centralize after-filter construction
	return page, nil
}

func (i *Index) DiscoverValues(ctx context.Context, field string, where string, top int) ([]backend.ValueCount, error) {
	var scope *plan.CompiledQuery
	if where != "" {
		cq, err := i.compileQuery(where)
		if err != nil {
			return nil, err
		}
		scope = &cq
	}
	return i.store.DiscoverValues(ctx, field, scope, top)
}

func (i *Index) DiscoverFields(ctx context.Context) ([]backend.FieldOverviewRow, error) {
	return i.store.DiscoverFields(ctx)
}

func (i *Index) Stats(ctx context.Context, field string, where string) (map[string]any, error) {
	var scope *plan.CompiledQuery
	if where != "" {
		cq, err := i.compileQuery(where)
		if err != nil {
			return nil, err
		}
		scope = &cq
	}
	return i.store.Stats(ctx, field, scope)
}

func (i *Index) ApplySchemaAdditive(ctx context.Context, newSchema schema.Schema) error {
	if err := newSchema.Validate(); err != nil {
		return err
	}
	if err := i.store.ApplySchemaAdditive(ctx, newSchema); err != nil {
		return err
	}
	i.schema = newSchema
	return nil
}

func (i *Index) MigrateRebuild(ctx context.Context, newName string, newSchema schema.Schema) error {
	if err := newSchema.Validate(); err != nil {
		return err
	}
	return i.store.MigrateRebuild(ctx, newName, newSchema)
}

func (i *Index) Optimize(ctx context.Context) error {
	return i.store.Optimize(ctx)
}

func (i *Index) Batch(ctx context.Context, b Batch) (int, error) {
	if err := b.ValidateBasic(); err != nil {
		return 0, err
	}
	// Default implementation (adapter may override later): replay ops one-by-one.
	// Adapters can provide a faster transaction/bulk path later.
	count := 0
	for _, op := range b.Ops {
		switch op.Kind {
		case BatchPut:
			if err := i.Put(ctx, op.Doc); err != nil {
				return count, err
			}
			count++
		case BatchDelete:
			ok, err := i.Delete(ctx, op.Path)
			if err != nil {
				return count, err
			}
			if ok {
				count++
			}
		}
	}
	return count, nil
}

// compileQuery runs parse->normalize->typecheck/compile.
func (i *Index) compileQuery(q string) (plan.CompiledQuery, error) {
	expr, err := query.Parse(q)
	if err != nil {
		return plan.CompiledQuery{}, err
	}
	expr, err = query.Normalize(expr)
	if err != nil {
		return plan.CompiledQuery{}, err
	}
	cq, err := plan.Compile(i.schema, expr, plan.CompileOptions{})
	if err != nil {
		return plan.CompiledQuery{}, err
	}
	return cq, nil
}

func (i *Index) resolveCursor(ctx context.Context, opts SearchOptions) (cursor.Position, error) {
	// Full cursor
	if !cursor.IsShortToken(opts.After) {
		pos, err := cursor.DecodeFull(opts.After)
		if err != nil {
			return cursor.Position{}, err
		}
		return pos, nil
	}
	// Short cursor: delegate to adapter via a tiny optional interface.
	h, _ := cursor.ShortHandle(opts.After)
	if r, ok := i.store.(backend.ShortCursorResolver); ok {
		return r.LoadShortCursor(ctx, h)
	}
	return cursor.Position{}, mserrors.NewError(mserrors.ErrCursor, "backend does not support short cursors")
}

// helper for shaping (kept for future use)
func decodeDocJSON(s string) (map[string]any, error) {
	var m map[string]any
	if err := json.Unmarshal([]byte(s), &m); err != nil {
		return nil, err
	}
	return m, nil
}
